<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Task Cups Prototype - Pollution Urgency</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.js"></script>
<style>
  body { 
    margin: 0; 
    background: #000; 
    color: #fff; 
    font-family: sans-serif; 
    touch-action: none;          /* Safari touch fix */
    -webkit-user-select: none;    /* Disable text selection */
    -webkit-touch-callout: none;  /* Disable long press menu */
  }
  canvas { touch-action: none; } /* Ensure canvas receives touches */
  #checklist { 
    position: fixed; 
    top: -30px; 
    left: 10px; 
    background: rgba(0,0,0,0.7); 
    padding: 10px; 
    border-radius: 5px; 
    display: none; 
  }
  #toggleTextBtn, #toggleMobileBtn, #toggleSubtaskBtn {
    position: fixed; 
    top: 10px; 
    padding: 10px; 
    background: #222; 
    color: #fff; 
    border: none; 
    border-radius: 5px; 
    cursor: pointer;
  }
  #toggleTextBtn { right: 10px; }
  #toggleMobileBtn { right: 200px; }
  #toggleSubtaskBtn { right: 350px; }
</style>
</head>
<body>
<div id="checklist">
  <strong>Setup Checklist</strong>
  <ul>
    <li id="cupsCreated">Cups created</li>
    <li id="particlesCreated">Particles created</li>
    <li id="animationRunning">Animation running</li>
    <li id="urgencyColor">Urgency color mapping</li>
  </ul>
</div>

<button id="toggleTextBtn">Hide Cup Titles & Deadlines</button>
<button id="toggleMobileBtn">Enable Mobile View</button>
<button id="toggleSubtaskBtn">Show Subtask Titles</button>

<script>
let cups = [];
let maxRipple = 60;
let showCupText = false;
let mobileView = false;
let showSubtaskTitles = false;
let touchStartTime = 0;
let longPressDuration = 500; // ms
let tappedParticle = null;

// --- Main Tasks ---
// (Keep your mainTasks array exactly as in your original code)

// --- Load / Save with Safari-safe localStorage ---
function safeStorageAvailable() {
  try { localStorage.setItem("test","1"); localStorage.removeItem("test"); return true; }
  catch(e){ console.warn("LocalStorage not available"); return false; }
}
let storageEnabled = safeStorageAvailable();

function loadCompletedState(){ if(!storageEnabled) return []; let saved = localStorage.getItem('completedParticles'); return saved?JSON.parse(saved):[]; }
function saveCompletedState(){ if(!storageEnabled) return; let completed=[]; for(let cup of cups){ completed.push(cup.particles.map(p=>p.completed)); } localStorage.setItem('completedParticles',JSON.stringify(completed)); }

// --- Cup Class ---
class Cup { /* keep your original Cup class unchanged */ }

// --- Particle Class ---
class Particle {
  constructor(x,y,name,cup,completed=false,highStress=false){
    this.pos = createVector(x,y);
    this.vel = createVector(random(-1.2,1.2),random(-1.2,1.2));
    this.r = 0.1;
    this.g = random(0.5,1);
    this.alpha = 150;
    this.name = name;
    this.cup = cup;
    this.completed = completed;
    this.fallSpeed = 2;
    this.urgency = 0;
    this.showNameUntil = 0;
    this.highStress = highStress;
    this.baseColor = highStress?color(255,0,0):cup.color;
    if(highStress) this.vel.mult(1.5);
    this.setSizes();
  }

  setSizes(){
    if(mobileView || windowWidth<600){ this.visualSize=24; this.touchSize=48; } 
    else { this.visualSize=12; this.touchSize=12; }
  }

  update(){
    if(!this.completed) this.pos.add(this.vel);

    // cup boundaries
    if(this.pos.x<this.cup.pos.x){ this.pos.x=this.cup.pos.x; this.vel.x*=-1; }
    if(this.pos.x>this.cup.pos.x+this.cup.w){ this.pos.x=this.cup.pos.x+this.cup.w; this.vel.x*=-1; }
    if(this.pos.y<this.cup.pos.y){ this.pos.y=this.cup.pos.y; this.vel.y*=-1; }
    if(this.pos.y>this.cup.pos.y+this.cup.h){ this.pos.y=this.cup.pos.y+this.cup.h; this.vel.y*=-1; }

    // urgency
    if(!this.completed){
      let now = new Date();
      let remaining = this.cup.deadline - now;
      let sourceUrgency = constrain(1-remaining/this.cup.deadlineTotal,0,1);
      this.urgency += (sourceUrgency-this.urgency)*0.02;

      for(let other of this.cup.particles){
        if(!other.completed && other!==this && dist(this.pos.x,this.pos.y,other.pos.x,other.pos.y)<50){
          other.urgency += (this.urgency-other.urgency)*0.01;
          other.urgency = constrain(other.urgency,0,1);
        }
      }

      // high-stress collisions
      if(this.highStress){
        let stressFactor = this.completed?max(0,1-(millis()%1000)/1000):1;
        for(let other of this.cup.particles){
          if(other===this||other.completed) continue;
          let myRadius=this.visualSize*0.75, otherRadius=other.visualSize*0.5;
          let minDist=myRadius+otherRadius+2;
          let d=dist(this.pos.x,this.pos.y,other.pos.x,other.pos.y);
          let speedMultiplier=0.05*this.visualSize;
          if(d===0){
            other.pos.add(createVector(random(-1,1),random(-1,1)).mult(stressFactor*speedMultiplier));
            other.vel.add(createVector(random(-0.5,0.5),random(-0.5,0.5)).mult(stressFactor*speedMultiplier));
          } else if(d<minDist){
            let overlap=minDist-d;
            let dir=p5.Vector.sub(other.pos,this.pos).normalize();
            other.pos.add(dir.copy().mult((overlap*0.75+0.5)*stressFactor*speedMultiplier));
            other.vel.add(dir.copy().mult((2.5+overlap*0.2)*stressFactor*speedMultiplier));
          }
          if(this.completed){
            let defaultSpeed=1.2;
            other.vel.x = lerp(other.vel.x, constrain(other.vel.x,-defaultSpeed,defaultSpeed),0.05);
            other.vel.y = lerp(other.vel.y, constrain(other.vel.y,-defaultSpeed,defaultSpeed),0.05);
          }
        }
      }

      this.color = lerpColor(this.baseColor, color(255,0,0), this.urgency);
    }

    // ripple - Safari-safe
    push();
    drawingContext.globalCompositeOperation = "lighter";
    noFill();
    stroke(this.color.levels[0],this.color.levels[1],this.color.levels[2],this.alpha);
    strokeWeight(2);
    ellipse(this.pos.x,this.pos.y,this.r*2);
    pop();
    this.r += this.g * (this.highStress?1.5:1);
    this.alpha = map(this.r,0,maxRipple,150,0);
    if(this.r>maxRipple){ this.r=0.1; this.alpha=150; }

    // draw particle
    noStroke();
    fill(this.completed?"green":this.color);
    let targetY = this.completed?this.cup.pos.y+this.cup.h-6:this.pos.y;
    if(this.completed && this.pos.y<targetY){ this.pos.y+=this.fallSpeed; if(this.pos.y>targetY)this.pos.y=targetY; }
    ellipse(this.pos.x,this.pos.y,this.visualSize);

    // show individual titles
    if((mobileView && millis()<this.showNameUntil) || this.highStress || this.urgency>0.8){
      fill((this.highStress||this.urgency>0.8)?"red":"white");
      textAlign(CENTER);
      textSize(16);
      text(this.name,this.pos.x,this.pos.y-25);
    }
  }

  toggleCompletion(){ this.completed=!this.completed; if(!this.completed)this.urgency=0; saveCompletedState(); }
}

// --- Setup ---
function setup(){
  let cnv = createCanvas(window.innerWidth, window.innerHeight);
  cnv.style('display','block');
  setTimeout(()=>resizeCanvas(window.innerWidth,window.innerHeight),200); // Safari viewport fix
  background(0);

  // rest of setup unchanged: cups creation, event listeners, etc.
}

// --- Draw ---
function draw(){
  background(0,20);
  for(let cup of cups) cup.update();
  document.getElementById("animationRunning").style.color="lime";
}

// --- Touch ---
function touchStarted(){ /* unchanged */ }
function touchEnded(){ /* unchanged */ }

// --- Mouse ---
function mousePressed(){ /* unchanged */ }
function mousePressedRight(e){ /* unchanged */ }
document.addEventListener("contextmenu", mousePressedRight);

// --- Window Resize ---
function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); }
</script>
</body>
</html>
